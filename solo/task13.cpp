#include <iostream>
#include <cstdlib>
#include <cstring>
#include "compare.h"

using namespace std;

int main(int argc, char* argv[]) {
    if (argc < 4) {
        cerr << "Использование: <функция> <число1> <число2> [эпсилон] [absEpsilon relEpsilon]" << endl;
        return 1;
    }

    const char* func = argv[1];
    if (!isValidFloat(argv[2]) || !isValidFloat(argv[3])) {
        cerr << "Ошибка: Аргументы чисел должны быть действительными числами с плавающей точкой." << endl;
        return 1;
    }

    float num1 = atof(argv[2]);
    float num2 = atof(argv[3]);

    if (strcmp(func, "approximatelyEqual") == 0) {
        if (argc != 5 || !isValidFloat(argv[4])) {
            cerr << "Использование: approximatelyEqual <число1> <число2> <эпсилон>" << endl;
            return 1;
        }
        float epsilon = atof(argv[4]);
        if (float_approximatelyEqual(num1, num2, epsilon)) {
            cout << "Числа равны." << endl;
        } else {
            cout << "Числа не равны." << endl;
        }
    } else if (strcmp(func, "approximatelyEqualAbsRel") == 0) {
        if (argc != 6 || !isValidFloat(argv[4]) || !isValidFloat(argv[5])) {
            cerr << "Использование: approximatelyEqualAbsRel <число1> <число2> <absEpsilon> <relEpsilon>" << endl;
            return 1;
        }
        float absEpsilon = atof(argv[4]);
        float relEpsilon = atof(argv[5]);
        if (float_approximatelyEqualAbsRel(num1, num2, absEpsilon, relEpsilon)) {
            cout << "Числа равны." << endl;
        } else {
            cout << "Числа не равны." << endl;
        }
    } else {
        cerr << "Неизвестная функция." << endl;
        return 1;
    }

    return 0;
}


// g++ -o Task13 task13.cpp compare.cpp
// ./Task13 approximatelyEqual 10.5 10.6 0.1
// ./Task13 approximatelyEqualAbsRel 100 99.5 0.5 0.01


// approximatelyEqual:
// Этот метод сравнивает два числа с плавающей точкой с помощью заданного значения эпсилона (погрешности).
// Числа считаются равными, если их разница не превышает заданное значение эпсилона.
// Если разница между числами меньше или равна эпсилону, то они считаются равными.
// Если разница между числами больше эпсилона, то они считаются неравными.
// approximatelyEqualAbsRel:
// Этот метод сравнивает два числа с плавающей точкой с помощью комбинации абсолютной и относительной погрешностей.
// Числа считаются равными, если их разница меньше или равна абсолютной погрешности, или если их относительная разница меньше относительной погрешности.
// Он сначала проверяет абсолютную погрешность: если разница между числами меньше или равна абсолютной погрешности, они считаются равными.
// Если разница между числами больше абсолютной погрешности, он проверяет относительную погрешность: если отношение разницы к большему из чисел меньше относительной погрешности, числа считаются равными.
// Если ни одно из условий не выполняется, числа считаются неравными.
// В обоих случаях, если разница между числами очень мала по сравнению с заданной погрешностью, то они считаются равными. Это помогает избежать проблем с точностью при сравнении чисел с плавающей точкой.

// approximatelyEqualAbsRel  100 99 0.001 0.01
// что пришлёт код при таком вводе
// При таком вводе код сравнит числа 100 и 99 с использованием функции approximatelyEqualAbsRel, принимая во внимание абсолютную погрешность 0.001 и относительную погрешность 0.01.
// Так как разница между числами составляет 1, что больше абсолютной погрешности 0.001, программа проверит отношение разницы к большему из чисел, т.е. отношение (100 - 99) / max(100, 99) = 0.01. Это значение меньше относительной погрешности 0.01.
// Следовательно, программа должна сообщить, что числа равны.